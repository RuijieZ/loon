
R version 3.4.1 (2017-06-30) -- "Single Candle"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ## as in the rgl package
> 
> library(loon)
Loading required package: tcltk
> 
> # options(demo.ask=FALSE)
> 
> is_windows <- Sys.info()['sysname'] == "Windows"
> 
> for(demo in demo(package="loon")$results[,"Item"]) {
+     if (!(demo %in% c("loon", "lsystem"))) {
+         # on windows all the image resizing seem to use up too much memory
+         # when all the demos are run sequentially
+         if (!(is_windows && grepl("^l_ng_", demo))) {
+             demo(demo, package="loon", character.only=TRUE)            
+         }
+     }
+ }


	demo(l_add_regressions)
	---- ~~~~~~~~~~~~~~~~~

> # Define a function addRegressionLines that takes a scatterplot
> # handle as argument and creates a GUI to fit regression lines
> # of a specific order to the selected points
> 
> local({
+ 
+     addRegressionLinesGUI <- function(p) {
+         force(p)
+         addRegressionLine <- function() {
+             sel <- p['selected']
+             if (sum(sel)==0) return()
+             xs <- p['x'][sel]; ys <- p['y'][sel]
+             fit <- lm(ys ~ poly(xs, as.numeric(tclvalue(degree))))
+             xrng <- seq(min(xs), max(xs), length.out = 20)
+             ypred <- predict(fit, newdata=data.frame(xs = xrng))
+             l_layer_line(p, x=xrng, y=ypred, color=as.character(color),
+                          linewidth = 4, index=0, label=paste("degree", tclvalue(degree)))
+             l_configure(p, color=color, glyph='ocircle', which=sel)
+         }
+         
+         updateColor <- function() {
+             col <- as.character(tcl('tk_chooseColor', initialcolor=color))
+             if (col!='') {
+                 tkconfigure(b_col, bg=col, activebackground=col)
+                 color <<- col
+             }
+         }
+         
+         tt <- tktoplevel()
+         tktitle(tt) <- 'Add Regression Line'
+         degree <- tclVar('1')
+         color <- 'red'
+         s <- tkscale(tt, orient='horizontal', variable=degree,
+                      from=1, to=8, resolution=1)
+         b_col <- tkbutton(tt, bg=color, activebackground=color, command=updateColor)
+         b_add <- tkbutton(tt, text='add', command=addRegressionLine)
+         tkgrid(tklabel(tt, text='degree:'), s, b_col, b_add, sticky='s', pady=5)
+         tkgrid.columnconfigure(tt, 1, weight=1)
+         tkgrid.configure(s, sticky='ew')
+     }  
+     
+     
+     ## For example, for generated data
+     x <- runif(500)*7
+     y <- sapply(x, function(x) {
+         if (0 <= x && x < 2) {
+             5*x + rnorm(1,0,1)
+         } else if (2 <= x && x < 5) {
+             8.6 + 2*x-.6*x^2 + rnorm(1,0,.5)
+         } else {
+             8.5 - log(x) + rnorm(1,0,.8)
+         }
+     })
+     
+     p <- l_plot(x,y)
+     addRegressionLinesGUI(p)
+ })
<Tcl>  


	demo(l_glyph_sizes)
	---- ~~~~~~~~~~~~~

> require(RnavGraphImageData) || stop("Neeed RnavGraphImageData package")
Loading required package: RnavGraphImageData
[1] TRUE

> if (loon:::.withTclImg) {
+     local({
+         # Plot glyphsizes for different glyphs
+         sizes <- c(0:10) # seq(15,25,by=5)
+         ns <- length(sizes)
+         
+         glyphs <- c('sizes', 'circle', 'square', 'triangle', 'diamond',
+                     'text', 'image', 'stars', 'parallel', 'polygon')
+         ng <- length(glyphs)
+         
+         ## ns+1 for labels
+         x <- rep(1:(ns+1), ng)
+         y <- rep(c(9, 8, 7.5, 7, 6.5, 6, 5, 3, 1,-1), each=ns+1)
+         
+         p <- l_plot(x,y, showLabels=FALSE)
+         
+         
+         for (i in seq_along(glyphs)) {
+             assign(paste0('i_',glyphs[i]), seq((i-1)*(ns+1)+1,i*(ns+1)))
+         }
+         
+         
+         ## Size Labels
+         labelsize <- 6
+         psizes <- rep(c(labelsize, sizes), ng)
+         
+         c_psizes <- as.character(psizes)
+         c_psizes[c_psizes=="0"] <- "<1" 
+         
+         g_sizes <- l_glyph_add_text(p, text = c_psizes, label="size labels")
+         
+         p['glyph'] <- g_sizes
+         p['size'] <- psizes
+         
+         l_configure(p, color='black', size=labelsize, which=i_sizes)
+         
+         ## Primitive Glyphs
+         l_configure(p, glyph='circle', which=i_circle)
+         l_configure(p, glyph='square', which=i_square)
+         l_configure(p, glyph='triangle', which=i_triangle)
+         l_configure(p, glyph='diamond', which=i_diamond)
+         
+         
+         ## text glyph
+         g_text <- l_glyph_add_text(p, text = rep("aA", p['n']), label='text glyphs')
+         l_configure(p, glyph=g_text, which=i_text)
+         
+         
+         ## Images
+         data(faces)
+         faces.imgs <- l_image_import_array(faces, 64, 64, img_in_row = FALSE)
+         faces.imgs[1]
+         g_image <- l_glyph_add_image(p, image=rep(faces.imgs[1], p['n']), label='frey faces')
+         l_configure(p, glyph=g_image, which=i_image)
+         
+         
+         ## Stars
+         g_stars <- l_glyph_add_serialaxes(p, data=oliveAcids,
+                                           label='star glyphs', showArea=FALSE,
+                                           showAxes = TRUE, showEnclosing = TRUE)
+         l_configure(p, glyph=g_stars, which=i_stars)
+         
+         ## Parallel
+         g_parallel <- l_glyph_add_serialaxes(p, data=oliveAcids,
+                                              label='parallel coords', linewidth = 3, axesLayout = 'parallel',
+                                              showAxes = TRUE, showEnclosing = TRUE, showArea=FALSE)
+         l_configure(p, glyph=g_parallel, which=i_parallel)
+         
+         
+         # Polygons 
+         # hand drawn
+         airplane_coords <- c(30.8,0.5,57.4,27.1,85.6,16.5,89.9,17,78.7,30.9,183.5,27.7,
+                              223.5,6.4,234.6,7.4,222.9,22.3,240,21.8,253.8,26.1,264.5,
+                              33.5,276.2,39.4,283.1,42,286.5,50.6,282,57.5,273.5,63.9,
+                              260.2,69.7,246.9,72.4,217.1,76.1,176.6,78.8,151.6,78.8,
+                              88.8,105.9,62.7,95.8,117,70.8,87.7,70.8,73.9,68.1,56.3,
+                              63.3,44.6,53.2,20.7,61.2,11.6,57.5,34,44.2)
+         x_ap <- airplane_coords[seq(1, length(airplane_coords), by=2)]
+         y_ap <- airplane_coords[seq(2, length(airplane_coords), by=2)]
+         ## center-scale
+         d_ap <- diff(range(x_ap, y_ap))/5 # 5 is min width or height of airplane if size <= 1
+         x_aps <- (x_ap-mean(x_ap))/d_ap 
+         y_aps <- (y_ap-mean(y_ap))/d_ap
+         
+         g_polygon <- l_glyph_add_polygon(p, x=lapply(seq_len(p['n']), function(arg) x_aps),
+                                          y = lapply(seq_len(p['n']), function(arg) y_aps),
+                                          label='airplane')
+         l_configure(p, glyph=g_polygon, which=i_polygon)
+         
+         
+         ## Row Labels
+         vapply(glyphs, function(g) {
+             get(paste0('i_', g))[1]    
+         }, numeric(1))## Row labeling
+         
+         g_row <- l_glyph_add_text(p, text=rep(glyphs, each= ns+1), label='glyph labels')
+         
+         i_rowlabels <- vapply(glyphs, function(g) {
+             get(paste0('i_', g))[1]    
+         }, numeric(1))
+         
+         l_configure(p, glyph=g_row, color='black', which=i_rowlabels)
+         
+     })  
+ } else {
+     cat("need the tkimg tcl extension installed to run this demo.\n")
+ }
scale images...
  done


	demo(l_glyphs)
	---- ~~~~~~~~

> require(PairViz) || stop("Package PairViz is required.")
Loading required package: PairViz
Loading required package: TSP
Loading required package: gtools
Loading required package: graph
Loading required package: BiocGenerics
Loading required package: parallel

Attaching package: 'BiocGenerics'

The following objects are masked from 'package:parallel':

    clusterApply, clusterApplyLB, clusterCall, clusterEvalQ,
    clusterExport, clusterMap, parApply, parCapply, parLapply,
    parLapplyLB, parRapply, parSapply, parSapplyLB

The following objects are masked from 'package:stats':

    IQR, mad, sd, var, xtabs

The following objects are masked from 'package:base':

    anyDuplicated, append, as.data.frame, cbind, colMeans, colnames,
    colSums, do.call, duplicated, eval, evalq, Filter, Find, get, grep,
    grepl, intersect, is.unsorted, lapply, lengths, Map, mapply, match,
    mget, order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank,
    rbind, Reduce, rowMeans, rownames, rowSums, sapply, setdiff, sort,
    table, tapply, union, unique, unsplit, which, which.max, which.min


Attaching package: 'graph'

The following object is masked from 'package:loon':

    complement

[1] TRUE

> local({
+     p <- with(olive, l_plot(oleic~arachidic, color=Area))
+ 
+     ## Text
+     readline("press the return key to continue: next are text glyphs")
+ 
+     gt <- l_glyph_add_text(p, text=as.character(olive$Area))
+     p['glyph'] <- gt
+     
+     ## Images
+     
+     if (loon:::.withTclImg) {
+         
+         readline("press the return key to continue: next are image glyphs")
+         
+         path <- file.path(find.package(package = "loon"), "images")
+         files <- list.files(path, full.names=TRUE)
+         imgs <- l_image_import_files(files)
+         names(imgs) <- gsub("\\.png$", "", basename(names(imgs)))
+         area <-  gsub("^.*-", "", as.character(olive$Area))
+         areaimages <- imgs[match(area, names(imgs))]
+         gi <- l_glyph_add_image(p, images=areaimages)
+         p['glyph'] <- gi
+         
+         
+         readline("press the return key to continue: next reuse single image")
+         
+         l_configure(c(p,gi), images=areaimages[1])
+         ## or also just
+         ## l_configure(gi, images=areaimages[1])
+     }
+ 
+     
+     ## Serialaxes
+     readline("press the return key to continue: next star glyphs")
+ 
+     sa <- l_glyph_add_serialaxes(p, data=oliveAcids)
+     l_configure(p, glyph=sa)
+     
+     readline("press the return key to continue: next configure stars")
+ 
+     l_configure(sa, showEnclosing=FALSE, linewidth=2)
+     l_configure(sa, showArea=FALSE)
+     
+     readline("press the return key to continue: next stack all Umbria glyphs")
+ 
+     p['selected'] <- olive$Area == "Umbria"
+     l_move_valign(p,'selected')
+     l_move_halign(p,'selected')
+     l_configure(p, size=40, which='selected')
+     l_scaleto_selected(p)
+     l_configure(sa, showEnclosing=TRUE, bboxColor="steelblue", showArea=FALSE)
+     p['selected'] <- FALSE
+ 
+     readline("press the return key to continue: next parallel coordinates")
+ 
+     l_move_reset(p)
+     p['size'] <- 4
+     l_scaleto_world(p)
+     l_configure(sa, axesLayout="parallel")
+ 
+     readline("press the return key to continue: next change the sequence")
+ 
+     l_configure(sa, sequence=as.vector(t(hpaths(names(olive)[-c(1,2)]))))
+     
+     readline("press the return key to continue: next show axes")
+ 
+     l_configure(sa, showAxes=TRUE)
+     
+     readline("press the return key to continue: switch back to star glyphs")
+     
+     l_configure(sa, axesLayout="radial", showAxes=FALSE, showEnclosing=FALSE)
+     
+ 
+     ## Polygon Glyphs
+     readline("press the return key to continue: add polygon glyphs")
+     
+     x_star <- 
+         c(-0.000864304235090734, 0.292999135695765, 0.949870354364736, 
+           0.474503025064823, 0.586862575626621, -0.000864304235090734, 
+           -0.586430423509075, -0.474070872947277, -0.949438202247191, -0.29256698357822)
+     y_star <-
+         c(-1, -0.403630077787381, -0.308556611927398, 0.153846153846154, 
+           0.808556611927398, 0.499567847882455, 0.808556611927398, 0.153846153846154, 
+           -0.308556611927398, -0.403630077787381)
+     x_cross <- 
+         c(-0.258931143762604, -0.258931143762604, -0.950374531835206, 
+           -0.950374531835206, -0.258931143762604, -0.258931143762604, 0.259651397291847, 
+           0.259651397291847, 0.948934024776722, 0.948934024776722, 0.259651397291847, 
+           0.259651397291847)
+     y_cross <-
+         c(-0.950374531835206, -0.258931143762604, -0.258931143762604, 
+           0.259651397291847, 0.259651397291847, 0.948934024776722, 0.948934024776722, 
+           0.259651397291847, 0.259651397291847, -0.258931143762604, -0.258931143762604, 
+           -0.950374531835206)
+     x_hexagon <-
+         c(0.773552290406223, 0, -0.773552290406223, -0.773552290406223, 
+           0, 0.773552290406223)
+     y_hexagon <- 
+         c(0.446917314894843, 0.894194756554307, 0.446917314894843, -0.447637568424085, 
+           -0.892754249495822, -0.447637568424085)
+     
+     
+     x_polygon_glyph <- lapply(as.character(olive$Region), function(region) {
+         if (region == "North") 
+             x_cross
+         else if (region == "South")
+             x_star
+         else
+             x_hexagon
+     })    
+     
+     y_polygon_glyph <- lapply(as.character(olive$Region), function(region) {
+         if (region == "North") 
+             y_cross
+         else if (region == "South")
+             y_star
+         else
+             y_hexagon
+     })    
+     
+     gl_pol <- l_glyph_add_polygon(p, x=x_polygon_glyph, y=y_polygon_glyph, label="polygon")
+     
+     p['glyph'] <- gl_pol
+     
+     readline("press the return key to continue: don't fill polygon glyph area")
+ 
+     gl_pol['showArea'] <- FALSE
+ 
+     ## Mix glyphs
+     readline("press the return key to continue: mix between different glyphs")
+ 
+     g <- sample(
+         c(
+             'circle', 'square', 'triangle', 'diamond',
+             'ocircle', 'osquare', 'otriangle', 'odiamond',
+             gt, 
+             if (loon:::.withTclImg) gi else NULL,
+             sa, gl_pol
+         ),
+         dim(olive)[1], replace=TRUE
+     )
+     p['glyph'] <- g
+ 
+     ## Pointrange Glyphs
+     readline("press the return key to continue: next pointrange glyphs")
+ 
+     avg <- with(chickwts, tapply(weight, feed, mean))
+     sd <- with(chickwts, tapply(weight, feed, sd))
+ 
+     min <- with(chickwts, tapply(weight, feed, min))
+     max <- with(chickwts, tapply(weight, feed, max))
+ 
+     p1 <- l_plot(avg~sd)
+     g.p <- l_glyph_add_pointrange(p1, ymin=min, ymax=max)
+ 
+     p1['glyph'] <- g.p
+ 
+ })
press the return key to continue: next are text glyphs
press the return key to continue: next are image glyphs
scale images...
  done
press the return key to continue: next reuse single image
press the return key to continue: next star glyphs
press the return key to continue: next configure stars
press the return key to continue: next stack all Umbria glyphs
press the return key to continue: next parallel coordinates
press the return key to continue: next change the sequence
press the return key to continue: next show axes
press the return key to continue: switch back to star glyphs
press the return key to continue: add polygon glyphs
press the return key to continue: don't fill polygon glyph area
press the return key to continue: mix between different glyphs
press the return key to continue: next pointrange glyphs


	demo(l_knn)
	---- ~~~~~

> local({
+     
+     highlight_knn <- function(p, data, k=5, method='euclidean') {
+ 
+         if(!is(data, 'data.frame'))
+             data <- as.data.frame(data)
+         
+         ## Create Custom Control Panel
+         tt <- tktoplevel()
+         
+         onOff <- tclVar('1')
+         tkgrid(tkcheckbutton(tt, text='on/off', variable=onOff), sticky='w')
+         
+         k <- tclVar(k)
+         f1 <- tkframe(tt)
+         
+         e <- tkentry(f1, width=3, textvariable=k)
+         tkbind(e, '<Return>', function()hNN())
+         tkgrid(f1, sticky='w')
+         tkpack(tklabel(f1, text='k='), e, side='left')
+         
+         tkgrid(tklabel(tt, text='Nearest to:'), sticky='w')
+         distFrom <- tclVar('points')
+         f2 <- tkframe(tt)
+         tkgrid(f2, sticky='w')
+         tkpack(tkradiobutton(f2, text='points', variable=distFrom,
+                              value='points', command=function()hNN()),
+                tkradiobutton(f2, text='mean', variable=distFrom,
+                              value='mean', command=function()hNN()),
+                side='left')
+         
+         tkgrid(tklabel(tt, text='Space:'), sticky='w')
+         chbtns <- lapply(names(data), function(name) {
+             bvar <- tclVar('1')
+             b <- tkcheckbutton(tt, text=name, variable=bvar, 
+                                command=function()hNN())
+             tkgrid(b, sticky='w', padx=2)
+             return(bvar)
+         })
+         
+         
+         ## Create Nearest neighbour highlighting Functionality
+         
+         if(!is(p, 'loon'))
+             class(p) <- "loon"
+         
+         n <- nrow(data)
+         ## Which variables are used for D
+         cachedSpaceSelection <- rep(TRUE, ncol(data))
+         D <- as.matrix(dist(data, method = method))
+         I <- matrix(rep(1:n, n), ncol=n, byrow=TRUE)
+         
+         inds <- 1:n # used for subsetting
+         
+         ## Cache point gyph attributes that are used for highlighting
+         glyphCache <- character(0)
+         whichCache <- integer(0)
+         sizeCache <- integer(0)
+         
+         ## Function that highlights nearest neighbours
+         hNN <- function() {
+             
+             ## reset cached point glyphs attributes
+             if (length(whichCache) > 0) {
+                 l_configure(p, glyph=glyphCache, size=sizeCache, which=whichCache)
+                 whichCache <<- integer(0)
+             }
+             
+             if (tclvalue(onOff) == '0') return()
+             
+             isel <- which(p['selected'])
+             if (length(isel) == 0 || length(isel) == n) return()
+             
+             spaceSelection <- vapply(chbtns,
+                                      function(b)as.logical(as.numeric(tclvalue(b))),
+                                      logical(1))
+             
+             if(tclvalue(distFrom)=='points') {
+                 if(!identical(cachedSpaceSelection, spaceSelection)) {
+                     D <<- as.matrix(dist(data[, spaceSelection]))
+                     cachedSpaceSelection <<- spaceSelection
+                 } 
+                 chng_which <- unique(c(I[isel, -isel])[order(c(D[isel, -isel]))])
+             } else {
+                 p_mean <- apply(data[isel, spaceSelection], 2, mean)
+                 d <- apply(data[-isel, spaceSelection], 1, 
+                            function(row) dist(rbind(row, p_mean)))
+                 
+                 chng_which <- (inds[-isel])[order(d)]
+             }
+             
+             kval <- tclvalue(k)
+             if (grepl('[[:digit:]]+', kval)) {
+                 kval <- as.numeric(kval)
+             } else {
+                 kval <- 5
+             }
+             
+             ksel <- min(length(chng_which),kval)
+             
+             whichCache <<- chng_which[1:ksel]
+             glyphCache <<- p['glyph'][whichCache]
+             sizeCache <<- p['size'][whichCache]
+             l_configure(p, glyph='csquare', size=seq(25, 8, length.out = ksel), which=whichCache)
+         }
+ 
+         l_bind_state(p, 'selected', hNN)
+     }  
+     
+     ## For example,
+     sOiveAcids <- data.frame(scale(oliveAcids))
+     p <- with(sOiveAcids, l_plot(oleic~stearic, color=olive$Area))
+     highlight_knn(p, data=sOiveAcids, k=5)
+     
+     l_aspect(p) <- 1
+     
+     readline("press the return key to continue: next in a navigation graph setting")
+ 
+     nav <- l_navgraph(oliveAcids, color=olive$Area)
+     highlight_knn(nav$plot, sOiveAcids)
+     l_aspect(nav$plot) <- 1
+     
+     
+ })
press the return key to continue: next in a navigation graph setting


	demo(l_layers)
	---- ~~~~~~~~

> local({
+     p <- with(olive,
+               l_plot(x=linoleic, y=oleic,
+                      color=Region, title="Olive Data"))
+     
+     
+     ## Layer a Group
+     l.g <- l_layer_group(p, label="Drawings", parent="root", index="end")
+     
+     
+     ## Layer Points
+     readline("press the return key to continue: next add points layer")
+     
+     l.pts <- l_layer_points(p,
+                             x=c(200, 450, 1800),
+                             y=c(6000, 8000, 7000),
+                             color=c("green", "orange", "lightblue"),
+                             parent=l.g)
+     
+     l_scaleto_layer(p, l.pts)
+     
+     readline("press the return key to continue: next scale to world")
+     
+     l_scaleto_world(p)
+     
+     
+     readline("press the return key to continue: next configure size and color")
+     
+     l_configure(l.pts, color="thistle", size=30)
+     
+     readline("press the return key to continue: next re-initialize points")
+     
+     l_configure(l.pts,
+                 x=seq(from=200,to=1600, length.out=20),
+                 y=seq(from=6000,to=8000, length.out=20),
+                 color="steelblue", size=20:39)
+     
+     
+     readline("press the return key to continue: next re-label and move layer")
+     
+     l_layer_relabel(p, l.pts, "Different Sizes")
+     l_layer_move(p, l.pts, parent="root")
+     
+     
+     ## Polygon
+     
+     readline("press the return key to continue: next layer a polygon")
+     
+     i <- with(olive, chull(linoleic, oleic))
+     
+     x.hull <- olive$linoleic[i]
+     y.hull <- olive$oleic[i]
+     
+     l_layer_polygon(p, x.hull, y.hull, color="thistle",
+                     linecolor="black", linewidth=4, parent=l.g)
+     
+ 
+     ## Rectangle
+ 
+     readline("press the return key to continue: next layer a rectangle")
+ 
+     l_layer_rectangle(p, x=c(1100, 1300), y=c(7600, 8300), linewidth=2)
+     
+     ## Oval
+     readline("press the return key to continue: next layer an oval")
+ 
+     l_layer_oval(p, x=c(1500, 1750), y=c(7900, 8100),
+                  color="", linecolor="orange", linewidth=4)
+     
+     ## Line
+     readline("press the return key to continue: next layer a (regression) line and polygon")
+     
+     x <- with(olive, linoleic[Region=="North"])
+     y <- with(olive, oleic[Region=="North"])
+     
+     fit <- lm(y~x)
+     ##summary(fit)
+     
+     xr <- seq(from=min(x), to=max(x), length.out=20)
+     yp <- predict(fit, data.frame(x=xr), interval="prediction")
+     
+     
+     l.pi <- l_layer_polygon(p, x=c(xr, rev(xr)),
+                             y=c(yp[,2],rev(yp[,3])),
+                             color="lightgreen",
+                             linecolor= "darkgreen", linewidth=2,
+                             label="predition interval west liguria")
+     
+     l.fit <- l_layer_line(p, x=xr, y=yp[,1],
+                           color="darkgreen", linewidth=8,
+                           label="fit west liguria")
+     
+     l_layer_move(p, l.pi, "root", "end")
+     l_layer_raise(p, l.pi)
+     
+     
+     ## Text (size does not work and color is gray)
+     
+     readline("press the return key to continue: next layer text")
+     
+     bbox <- l_layer_bbox(p, "root")
+     
+     l_layer_texts(p, x=seq(from=bbox[1], to=bbox[3], length.out=length(LETTERS)),
+                  y=rev(seq(from=bbox[2], to=bbox[4], length.out=length(LETTERS))),
+                  text=LETTERS, size=seq_along(LETTERS),
+                  angle=seq_along(LETTERS)/length(LETTERS)*360)
+ 
+ })
press the return key to continue: next add points layer
press the return key to continue: next scale to world
press the return key to continue: next configure size and color
press the return key to continue: next re-initialize points
press the return key to continue: next re-label and move layer
press the return key to continue: next layer a polygon
press the return key to continue: next layer a rectangle
press the return key to continue: next layer an oval
press the return key to continue: next layer a (regression) line and polygon
press the return key to continue: next layer text
loon layer "texts" of type texts of plot .l7.plot
[1] "layer7"


	demo(l_layout)
	---- ~~~~~~~~

> local({
+     ## Tk geometry managers like grid and pack may be used
+     ## to place the widgets
+ 
+     ## With pack stack three scatterplots that share the same x on top
+     ## and bind the zoomX and panX
+     tt <- tktoplevel()
+     tktitle(tt) <- "Using the pack geometry manager"
+     
+     attach(iris)
+     p1 <- l_plot(parent=tt, x=Sepal.Width, y=Petal.Width, color=Species,
+                  linkingGroup="iris", showLabels=FALSE)
+     p2 <- l_plot(parent=tt, x=Sepal.Width, y=Petal.Length,
+                  linkingGroup="iris", showLabels=FALSE)
+     p3 <- l_plot(parent=tt, x=Sepal.Width, y=Sepal.Length,
+                  linkingGroup="iris", showLabels=FALSE)
+     s <- l_serialaxes(parent=tt, iris[,-5], linkingGroup="iris",
+                              axesLayout="parallel")
+ 
+     detach(iris)
+ 
+     ## make the canvas resize to fairly small
+ 
+     for (p in c(p1,p2,p3,s)) {
+         tkconfigure(paste(p,".canvas", sep=''), width=200, height=100)
+     }
+     
+     tkpack(p1, p2, p3, s, fill="both", expand=TRUE)
+     
+     
+     ## Bind so that they show the same x range
+     l_bind_state(p1, c("panX", "zoomX"), function(W)updateZoomPan(W))
+     l_bind_state(p2, c("panX", "zoomX"), function(W)updateZoomPan(W))
+     l_bind_state(p3, c("panX", "zoomX"), function(W)updateZoomPan(W))
+ 
+     busy <- FALSE
+     updateZoomPan <- function(widget) {
+         if (!busy) {
+             busy <- TRUE
+             zoomX <- l_cget(widget, "zoomX")
+             panX <- l_cget(widget, "panX")
+ 
+             for (w in c(p1, p2, p3)) {
+                 l_configure(w, panX=panX, zoomX=zoomX, zoomY=zoomX)
+             }
+             
+             busy <- FALSE
+         }
+     }
+     
+ 
+     readline("press the return key to continue: next scatterplot matrix with grid")
+     
+     tt2 <- tktoplevel()
+     tktitle(tt2) <- "Scatterplot Maxtrix Using Grid"
+ 
+     nvar <- 7
+     pair <- combn(3:10, 2)
+ 
+     ## create plots
+     plots <- apply(pair, 2, function(col) {
+         l_plot(parent=tt2, olive[,col[2]], olive[,col[1]], showLabels=FALSE)
+     })
+ 
+     ## resize the min canvas size
+     sapply(plots, function(p) {
+         tkconfigure(paste(p,'.canvas',sep=''), width=50, height=50)
+     })
+ 
+     ## grid layout
+     apply(rbind(plots, pair-2), 2, function(col) {
+         tkgrid(col[1], row=col[2], column=col[3], sticky="nesw")
+     })
+     
+     ## Column and Row wheight such that the cells expand
+     for (i in 1:(nvar+1)) {
+         tkgrid.columnconfigure(tt2, i, weight = 1)
+         tkgrid.rowconfigure(tt2, i, weight = 1)
+     }
+     
+     ## Add Variable Label
+     for (i in 3:10) {
+         lab <- tklabel(tt2, text=names(olive)[i])
+         tkgrid(lab, row = i - 2, column = i - 2)
+     }
+ 
+     ## Link Plots and specify color
+     ## sync=push is cheaper
+     sapply(plots, function(p)l_configure(p, linkingGroup="olive", sync="push"))
+ 
+     l_configure(plots[1], color=olive$Area)
+            
+     
+     
+ })
press the return key to continue: next scatterplot matrix with grid


	demo(l_linkPrimitiveGlyphs)
	---- ~~~~~~~~~~~~~~~~~~~~~

> ## The suported point glyph primitives are: circle, square, triangle,
> ## and rhombus. These glyphs are available for every scatterplot.
> ##
> ## So a call
> ##
> ## p['glyph'] <- "rhombus"
> ##
> ## will change every point glyph to a rhombus.
> ##
> ## Generally glyphs can not be linked among scatterplots, as nothing
> ## guarantees that a particular (image, text, boxplot, etc...) glyph
> ## is available for a scatterplot. However primitive shapes can be
> ## linked, but it must be done manually as this demo shows.
> ##
> ## An simpler way, but less secure, is to set glyph to be a linked
> ## state:
> ##
> ## states <- c(l_getLinkedStates(p1), 'glyph')
> ## l_setLinkedStates(p1, states)
> ## l_setLinkedStates(p2, states)
> 
> 
> local({
+ 
+     p1 <- with(iris,
+                l_plot(Sepal.Length, Petal.Width, color=Species,
+                       linkingGroup="iris"))
+     p2 <- with(iris,
+                l_plot(Petal.Length, Sepal.Width, color=Species,
+                       linkingGroup="iris"))
+ 
+     l_bind_state(p1, "glyph", function(W)syncglyphs(W))
+     l_bind_state(p2, "glyph", function(W)syncglyphs(W))
+ 
+ 
+     tosync <- c(p1, p2)
+ 
+     isbusy <- FALSE
+     syncglyphs <- function(widget) {
+         if (isbusy) {return()}
+         
+         glyph <- l_cget(widget, "glyph")
+         if (any(!(glyph %in% c("circle", "square",
+                                "triangle", "diamond", "ocircle",
+                                "osquare", "otriangle", "odiamond")))) {
+             stop(paste("Widget", widget,
+                        "has a glyph that is not a primitive glyph shape."))
+         }
+         
+         isbusy <- TRUE
+         for(p in tosync) {
+             if (p != widget) {
+                 l_configure(p, glyph=glyph)
+             }
+         }
+         isbusy <- FALSE
+     }
+     
+     
+ })


	demo(l_linking)
	---- ~~~~~~~~~

> local({
+ 
+     p1 <- with(trees,
+                l_plot(Girth, Height, linkingGroup="trees"))
+ 
+     p2 <- with(trees,
+                l_plot(Height, Volume, linkingGroup="trees"))
+ 
+     p3 <- with(trees,
+                l_plot(Girth, Volume, color="red"))
+ 
+     l_configure(p3, linkingGroup="trees", sync="push")
+ 
+     readline("press the return key to continue: next disable linking of color for p3")
+ 
+     l_getLinkedStates(p3)
+     l_setLinkedStates(p3, c("active", "size", "selected"))
+ 
+     readline("press the return key to continue: next add serialaxes plot")
+ 
+     s <- l_serialaxes(trees, linkingGroup="trees")
+     
+     readline("press the return key to continue: next demonstrate linkingKey")
+ 
+     p4 <- l_plot(1:9,1:9, color="orange",
+                  linkingKey=LETTERS[2:10], linkingGroup="letters")
+     g4.t <- l_glyph_add_text(p4, text=LETTERS[2:10])
+     l_configure(p4, glyph=g4.t, size=10)
+ 
+ 
+     p5 <- l_plot(1:4,1:4, color="green",
+                  linkingKey=LETTERS[5:8], linkingGroup="letters")
+     g5.t <- l_glyph_add_text(p5, text=LETTERS[5:8])
+     l_configure(p5, glyph=g5.t, size=10)
+     
+ })
press the return key to continue: next disable linking of color for p3
press the return key to continue: next add serialaxes plot
press the return key to continue: next demonstrate linkingKey


	demo(l_map)
	---- ~~~~~

> require(maps) || stop("package maps needed.")
Loading required package: maps
[1] TRUE

> local({
+ 
+     ## Maps from the map library
+     canada <- map("world",  "Canada", fill=TRUE, plot=FALSE)
+     pmap <- l_plot()
+ 
+     ## Color the lakes
+     id <- l_layer(pmap, canada,
+                   color = ifelse(grepl("lake", canada$names,
+                       ignore.case=TRUE), "lightblue", ""), asSingleLayer=FALSE)
+     l_scaleto_layer(pmap, id)
+ 
+     ## Or manually
+     ##l_layer(pmap, target='layer69', color="lightblue")  # Lake Winnipeg
+     ##l_layer(pmap, target='layer33', color="lightblue")  # Great Slave Lake
+     ##l_layer(pmap, target='layer15', color="lightblue")  # Great Bear Lake
+       
+     readline("press the return key to continue: next add points to scatterplot")
+ 
+     data(world.cities)
+     canada.cities <- subset(world.cities,
+                             grepl("canada", country.etc , ignore.case=TRUE))
+     
+     with(canada.cities,
+          l_configure(pmap, x=long, y=lat))
+     l_scaleto_world(pmap)
+ 
+     readline("press the return key to continue: next add city name glyphs")
+     
+     g.t <- l_glyph_add_text(pmap, text=canada.cities$name)
+     pmap['glyph'] <- g.t
+     
+ })
press the return key to continue: next add points to scatterplot
press the return key to continue: next add city name glyphs


	demo(l_map_sp)
	---- ~~~~~~~~

> require(sp) || stop("package sp qequired")
Loading required package: sp
[1] TRUE

> local({
+ 
+     if (FALSE) {
+         con <- url("http://biogeo.ucdavis.edu/data/gadm2/R/CHE_adm0.RData")
+         load(con)
+         close(con)
+         
+         p <- l_plot()
+         g <- l_layer_group(p, label="Switzerland")
+         m <- l_layer(p, gadm, label="Switzerland", parent=g,
+                      color="", linecolor="black")
+         l_scaleto_world(p)
+         
+         readline("press the return key to continue: map with multiple layers")    
+         
+         l_layer_hide(p, g)
+         
+         g1 <- l_layer_group(p, label="Swiss Cantons")
+         
+         con <- url("http://biogeo.ucdavis.edu/data/gadm2/R/CHE_adm1.RData")
+         load(con)
+         close(con)
+         
+         m1 <- l_layer(p, gadm, label="Swiss Cantons", parent=g1,
+                       color="", linecolor="red")
+         
+                                         #    ## name the layers
+         cantons <- gadm@data$NAME_1[gadm@plotOrder]
+         
+         for (i in 1:length(m1)) {
+             sapply(m1[[i]], function(l)l_layer_relabel(p, l, cantons[i]))
+         }
+         
+     } else {
+         cat(paste0('loon demo l_map_sp should be evaluated by hand\nFind the demo file at: ',
+                    system.file('demo','l_map_sp.R', package='loon'),'\n'))
+     }
+     ## l_aspect(p) <- 5/3
+     
+ })
loon demo l_map_sp should be evaluated by hand
Find the demo file at: /home/adrian/Desktop/loon/loon.Rcheck/loon/demo/l_map_sp.R


	demo(l_ng_dimred)
	---- ~~~~~~~~~~~

> require(MASS) || stop("MASS library required")
Loading required package: MASS
[1] TRUE

> require(kernlab)  || stop("kernlab library required")
Loading required package: kernlab
[1] TRUE

> require(RDRToolbox)  || stop("RDRToolbox library required")
Loading required package: RDRToolbox
[1] TRUE

> require(RColorBrewer) || stop("RColorBrewer library required")
Loading required package: RColorBrewer
[1] TRUE

> local({
+     
+     ## PCA
+     obj.pca  <- prcomp(oliveAcids, scale=TRUE)
+     olive_pca <- obj.pca$x
+     
+     ## FDA
+     obj.lda <- with(olive, MASS::lda(Area~palmitic+palmitoleic+stearic+oleic+ 
+                                          linoleic+linolenic+arachidic+eicosenoic))
+     olive_lda <- MASS:::predict.lda(obj.lda, newdata = olive)$x
+     
+     dim(olive_lda)
+     
+     ## Multidimensional scaling
+     D <- dist(scale(oliveAcids))
+     
+     ## Metric
+     olive_linear_mds <- cmdscale(d = D, k=5)
+     
+     ## Non-metric (Kruskal with Stress)
+     olive_nonlinear_mds <- MASS::isoMDS(d = D, k=5)$points
+     
+     ## Kernel PCA
+     obj.kpca <- kernlab::kpca(scale(oliveAcids),
+                               kernel='polydot',
+                               kpar=list(degree=3, offset=1),
+                               features=5)
+     
+     olive_kpca <- rotated(obj.kpca)
+     
+     
+     ##olive_lda Kernel Discriminant Analysis
+     ##library(ks)
+     
+     ## Isomap
+     olive_isomap <- RDRToolbox::Isomap(data=scale(oliveAcids), dim=5, k=6)$dim5
+     
+     
+     ## LLE
+     olive_LLE <- RDRToolbox::LLE(data=as.matrix(oliveAcids), dim=5, k=6)
+     
+     
+     ## Now look at this using navigation graphs
+     
+     G <- completegraph(nodes=paste0('d', seq(1,5)))
+     LG <- linegraph(G)
+     LGnot <- loon::complement(LG)
+     
+     g <- l_graph(LG)
+     gs <- l_graphswitch(parent=tkwinfo('toplevel', g), activewidget = g)
+     tkpack.forget(g)
+     tkpack(gs, side='right', fill='y')
+     tkpack(g, side='right', fill='y', expand=TRUE)
+     
+     l_graphswitch_add(gs, LG, label='3d transition')
+     l_graphswitch_add(gs, LGnot, label='4d transition')
+     
+     
+     ## Navigators & contexts
+     allData <- list(olive_pca,
+                     olive_lda,
+                     olive_linear_mds,
+                     olive_nonlinear_mds,
+                     olive_kpca,
+                     olive_isomap,
+                     olive_LLE)
+     
+     ndata <- function(dat, k=5) {
+         d <- dat[, 1:5]
+         colnames(d) <- paste0('d', seq(1,k)) 
+         as.data.frame(d)
+     }
+     
+     tt <- tktoplevel()
+     tktitle(tt) <- "plots"
+     
+     objs <- Map( function(data, col, label) {
+         p <- l_plot(parent=tt, linkingGroup='olive', title=label)
+         nav <- l_navigator_add(g, color=col)
+         nav['label'] <-  label
+         con <- l_context_add_geodesic2d(nav, data=ndata(data),
+                                         command = paste0(p, " configure -x %x -y %y -xlabel %xlabel -ylabel %ylabel"))
+         l_configure(p, color=olive$Area)
+         list(nav, con, p)    
+     }, allData, brewer.pal(7, "Set2"), c('pca', 'lda', 'lmds', 'nlmds', 'kpca', 'isomap', 'lle'))
+     
+     plots <- lapply(objs, function(x) x[[3]]) 
+     
+     do.call(tkgrid, c(plots[1:4], sticky='nesw'))
+     do.call(tkgrid, c(plots[5:7], sticky='nesw'))
+     sapply(0:3, function(i)tkgrid.columnconfigure(tt, i, weight=1))
+     sapply(0:1, function(i)tkgrid.rowconfigure(tt, i, weight=1))
+     
+     sapply(plots, function(p)l_scaleto_world(p))
+     
+     l_zoom(g, 0.9^2) ## zoom out to show the labels
+ 
+     
+     ## compare this with the original data    
+     nav <- l_navgraph(oliveAcids, color=olive$Area,
+                       linkingGroup='olive', sync='pull',
+                       title='original data')
+     
+ })
initial  value 3.745414 
iter   5 value 2.667413
iter  10 value 2.513637
final  value 2.493434 
converged
Computing distance matrix ... done
Building graph with shortest paths (using 6 nearest neighbours) ... done
Computing low dimensional embedding ... done
number of samples: 572
reduction from 8 to 5 dimensions
number of connected components in graph: 1
Computing distance matrix ... done
Computing low dimensional emmbedding (using 6 nearest neighbours)... done


	demo(l_ng_images_faces)
	---- ~~~~~~~~~~~~~~~~~

> require(RnavGraphImageData) || stop('You need the RnavGraphImageData package installed!')
[1] TRUE

> require(PairViz) || stop('You need the PairViz package installed!')
[1] TRUE

> local({
+     data(faces)
+     
+     faces.imgs <- l_image_import_array(faces, 64, 64, img_in_row = FALSE)
+     l_imageviewer(faces.imgs)
+     
+     group <- rep(1:40, each = 10)
+     
+     ## Multidimensional Scaling
+     D <- L2Distance(as.matrix(faces),as.matrix(faces))
+ 
+     faces.mds <- as.data.frame(cmdscale(D,k=4))
+     names(faces.mds) <- paste('pc',1:4,sep = '')
+ 
+     
+     nav <- l_navgraph(faces.mds, color=gsub("FF$","",rainbow(40)[group]))
+     
+     gl <- l_glyph_add_image(nav$plot, images=faces.imgs, label="olivetti faces")
+     nav$plot['glyph'] <- gl
+     
+ })
scale images...
  done

> cat(paste("\n\nThe source code of this demo file is located at:\n",
+           system.file("demo", "l_ng_images_faces.R", package="loon"),"\n\n\n"))


The source code of this demo file is located at:
 /home/adrian/Desktop/loon/loon.Rcheck/loon/demo/l_ng_images_faces.R 




	demo(l_ng_images_frey_LLE)
	---- ~~~~~~~~~~~~~~~~~~~~

> require(RnavGraphImageData) || stop('You need the RnavGraphImageData package installed!')
[1] TRUE

> require(RDRToolbox)|| stop('You need the RDRToolbox package installed!')
[1] TRUE

> local({
+     data(frey)
+     
+     ## LLE
+     frey.lle <- LLE(t(frey), dim=5, k=12)
+ 
+     frey.lle <- as.data.frame(frey.lle)
+     names(frey.lle) <- paste("V",1:5, sep="")
+ 
+     
+     ## Images
+     ## sample every third image
+     sel <- seq(1,dim(frey)[2],3)			
+     
+     frey.imgs <-  l_image_import_array(frey[,sel],28,20, img_in_row = FALSE, rotate = 90)
+     l_imageviewer(frey.imgs)
+     
+     nav <- l_navgraph(frey.lle[sel,])
+     
+     gl <- l_glyph_add_image(nav$plot, images=frey.imgs, label="frey faces")
+     nav$plot['glyph'] <- gl
+ 
+ })
Computing distance matrix ... done
Computing low dimensional emmbedding (using 12 nearest neighbours)... done
scale images...
  done

> cat(paste("\n\nThe source code of this demo file is located at:\n",system.file("demo", "l_ng_images_frey_LLE.R", package="loon"),"\n\n\n"))


The source code of this demo file is located at:
 /home/adrian/Desktop/loon/loon.Rcheck/loon/demo/l_ng_images_frey_LLE.R 




	demo(l_ng_images_frey_isomap)
	---- ~~~~~~~~~~~~~~~~~~~~~~~

> require(RnavGraphImageData) || stop('You need the RnavGraphImageData package installed!')
[1] TRUE

> local({
+     data(frey)
+ 
+     ## isomap data dimensionality reduction
+     ## this takes a bit of time, hence we provide the pre-calculated dimensions
+     
+     ##require(vegan) || stop("library vegan is needed for this demo.")    
+     freyT <- t(frey)
+     dims <- 6 
+     ##dise <- vegdist(freyT, method="euclidean")
+     ##ord <- isomap(dise,k = 12, ndim= dims, fragmentedOK = TRUE)
+     data(ordfrey)
+ 
+     iso.frey <- as.data.frame(ordfrey$points)
+     
+     
+     ## Images
+     ## sample every third image
+     sel <- seq(1,dim(frey)[2],3)
+     frey.imgs <- l_image_import_array(frey[,sel], 28,20,
+                                       img_in_row = FALSE, rotate = 90)
+     l_imageviewer(frey.imgs)
+ 
+     nav <- l_navgraph(iso.frey[sel,])
+ 
+     gl <- l_glyph_add_image(nav$plot, images=frey.imgs, label="frey faces")
+     nav$plot['glyph'] <- gl
+ 
+ })
scale images...
  done

> cat(paste("\n\nThe source code of this demo file is located at:\n",
+           system.file("demo", "l_ng_images_frey_isomap.R", package="loon"),"\n\n\n"))


The source code of this demo file is located at:
 /home/adrian/Desktop/loon/loon.Rcheck/loon/demo/l_ng_images_frey_isomap.R 




	demo(l_power)
	---- ~~~~~~~

> # Define a function power that creates a scatterplot with
> # two scales to transform the axes.
> 
> local({
+     
+     power <- function(x, y, from=-5, to=5, ...) {
+         
+         tt <- tktoplevel()
+         tktitle(tt) <- "Box-Cox Power Transformation"
+         p <- l_plot(x=x, y=y, parent=tt, ...)
+         lambda_x <- tclVar('1')
+         lambda_y <- tclVar('1')
+         sx <- tkscale(tt, orient='horizontal',
+                       variable=lambda_x, from=from, to=to, resolution=0.1)
+         sy <- tkscale(tt, orient='vertical',
+                       variable=lambda_y, from=to, to=from, resolution=0.1)
+         
+         tkgrid(sy, row=0, column=0, sticky="ns")
+         tkgrid(p, row=0, column=1, sticky="nswe")
+         tkgrid(sx, row=1, column=1, sticky="we")
+         tkgrid.columnconfigure(tt, 1, weight=1)
+         tkgrid.rowconfigure(tt, 0, weight=1)
+         
+         powerfun <- function(x, lambda) {
+             if (lambda == 0)
+                 log(x)
+             else
+                 (x^lambda-1)/lambda
+         }
+         
+         update <- function(...) {
+             l_configure(p,
+                         x = powerfun(x, as.numeric(tclvalue(lambda_x))),
+                         y = powerfun(y, as.numeric(tclvalue(lambda_y))))
+             l_scaleto_world(p)
+         }
+         
+         tkconfigure(sx, command=update)    
+         tkconfigure(sy, command=update)    
+         
+         invisible(p)    
+     }
+     
+     p <- with(MASS::mammals, power(body, brain,
+                                    xlabel="body weight",
+                                    ylabel="brain weight",
+                                    title="Brain and Body Weights for 62 Species of Land Mammals",
+                                    itemLabel=rownames(MASS::mammals),
+                                    showItemLabels=TRUE))
+     
+ })


	demo(l_regression)
	---- ~~~~~~~~~~~~

> local({
+     p1 <- with(faithful, 
+                l_plot(x=eruptions, y=waiting,
+                       size=10,
+                       xlabel="Duration of eruption (minutes)",
+                       ylabel="Waiting time to next eruption (minutes)",
+                       title="Old faithful geyser",
+                       showGuides=TRUE
+                )
+     )
+     
+     ## Add the least squares fitted line
+     
+     fit <- lm(waiting~eruptions, data=faithful)
+     
+     fitx <- range(faithful$eruptions)
+     xdelta <- diff(fitx)/5
+     xprange <- fitx + c(-xdelta,xdelta)
+     fity <- predict(fit,data.frame(eruptions=xprange))
+     
+     l <- l_layer_line(p1, xprange, fity, color="black", 
+                       linewidth=2, label="least squares fitted line")
+     
+     
+     ## confidence intervals for the mean
+     
+     xpvals <- seq(from=min(xprange),to=max(xprange),
+                   length.out=60)
+     
+     
+     conf90 <- predict(fit, data.frame(eruptions=xpvals),
+                       interval="confidence", level=0.90)
+     conf95 <- predict(fit, data.frame(eruptions=xpvals),
+                       interval="confidence", level=0.95)
+     conf99 <- predict(fit, data.frame(eruptions=xpvals),
+                       interval="confidence", level=0.99)
+     
+     confg <- l_layer_group(p1, label="Confidence intervals", index="end")
+     
+     l_layer_polygon(p1, 
+                     x=c(xpvals,rev(xpvals)), 
+                     y=c(conf90[,2],rev(conf90[,3])),
+                     color="lightblue3", 
+                     parent=confg, 
+                     label="90% confidence",
+                     index="end") 
+     
+     l_layer_polygon(p1, 
+                     x=c(xpvals,rev(xpvals)), 
+                     y=c(conf95[,2],rev(conf95[,3])),
+                     color="lightblue2", 
+                     parent=confg, 
+                     label="95% confidence",
+                     index="end") 
+     
+     l_layer_polygon(p1, 
+                     x=c(xpvals,rev(xpvals)), 
+                     y=c(conf99[,2],rev(conf99[,3])),
+                     color="lightblue1", 
+                     parent=confg, 
+                     label="99% confidence",
+                     index="end") 
+     
+     
+     
+     ## prediction intervals for observations
+     
+     pred90 <- predict(fit, data.frame(eruptions=xpvals),
+                       interval="prediction", level=0.90)
+     pred95 <- predict(fit, data.frame(eruptions=xpvals),
+                       interval="prediction", level=0.95)
+     pred99 <- predict(fit, data.frame(eruptions=xpvals),
+                       interval="prediction", level=0.99)
+     
+     predg <- l_layer_group(p1, label="prediction intervals", index="end")
+     
+     l_layer_polygon(p1, 
+                     x=c(xpvals,rev(xpvals)), 
+                     y=c(pred90[,2],rev(pred90[,3])),
+                     color="lightpink3", 
+                     parent=predg, 
+                     label="90% prediction",
+                     index="end") 
+     
+     l_layer_polygon(p1, 
+                     x=c(xpvals,rev(xpvals)), 
+                     y=c(pred95[,2],rev(pred95[,3])),
+                     color="lightpink2", 
+                     parent=predg, 
+                     label="95% prediction",
+                     index="end") 
+     
+     l_layer_polygon(p1, 
+                     x=c(xpvals,rev(xpvals)), 
+                     y=c(pred99[,2],rev(pred99[,3])),
+                     color="lightpink1", 
+                     parent=predg, 
+                     label="99% prediction",
+                     index="end") 
+     
+     
+     #
+     # Plot residuals versus fit
+     
+     p2 <-  l_plot(x=fit$fitted, y=fit$resid,
+                   size=10,
+                   xlabel="Fitted values",
+                   ylabel="Residuals",
+                   title="Old faithful geyser: least squares fit",
+                   showGuides=TRUE,
+                   showScales=TRUE,
+                   linkingGroup="Old faithful"
+     )
+     # Add a horizontal line at zero residual
+     fxrange <- range(fit$fitted)
+     fxdelta <- diff(fxrange)/5
+     fxrange <- fxrange + c(-fxdelta,fxdelta)
+     l_layer_line(p2, fxrange, rep(0,length(fxrange)), color="black", 
+                  linewidth=2, label="zero line",index="end")
+     
+     #
+     # Add p1 to this linking group, pull the scatterplot display values from the group
+     #
+     
+     l_configure(p1, linkingGroup="Old faithful", sync="pull")
+     
+     
+     #
+     # normal qq plot of residuals with 
+     # pointwise intervals simulated from normal
+     #
+     
+     n <- length(fit$resid)
+     
+     frac <- ((1:n)-0.5)/n
+     quantiles <- qnorm(frac)
+     
+     p3 <-  l_plot(x=quantiles, y=sort(fit$resid),
+                   size=10,
+                   xlabel="Gaussian quantiles",
+                   ylabel="Ordered residuals",
+                   title="Old faithful geyser: qqplot, as in qqtest pkg",
+                   showGuides=TRUE,
+                   linkingGroup="Old faithful",
+                   linkingKey=order(fit$resid)-1   #default linking map is zero based
+     )
+     
+     #
+     # Rest is just to add simulated pointwise intervals (stolen from qqtest package in R)
+     #
+     nreps <- 100
+     reps <- rnorm(n * nreps)
+     # Get a reasonable location and scale from the qqplot
+     qql <- MASS::rlm(sort(fit$resid) ~ 1 + quantiles, psi = MASS::psi.bisquare, 
+                      method = "MM")
+     loc <- qql$coefficients[1]
+     scale <- qql$coefficients[2]
+     reps <- loc + scale * reps
+     reps <- array(reps, dim = c(nreps, n))
+     reps <- apply(reps, 1, sort)
+     
+     #
+     # What central percents do we want to offer on the layers?
+     #
+     centralPercents <- c(0.90, 0.95, 0.99)
+     
+     nLevels <- length(centralPercents)
+     centralPercents <- sort(centralPercents)
+     SymmetricAdjust <- (1 - centralPercents)/2
+     bottomPcts <- (1 - centralPercents) - SymmetricAdjust
+     topPcts <- centralPercents + SymmetricAdjust
+     Pcts <- c(rev(bottomPcts), topPcts)
+     NumsPct <- apply(reps, 1, function(x) { quantile(x, Pcts)})
+     
+     #
+     # line characteristics and adding lines
+     #
+     
+     lineCols <- c("grey80", "grey50", "grey10")
+     lwidth <- rep(2, nLevels)
+     
+     #i <- 0
+     
+     for (i in 1:nLevels) {
+         # i <- i+1
+         actualPercent <- centralPercents[nLevels-i+1]
+         layer_group_name <- paste("Simulated ",
+                                   round(100*actualPercent),
+                                   "% pointwise central intervals",
+                                   sep="")
+         
+         layer_group <- l_layer_group(p3, label=layer_group_name, index="end")
+         
+         dashPattern <- c(15*i,5)
+         
+         l_layer_line(p3, quantiles, NumsPct[i, ], 
+                      color=lineCols[i], 
+                      linewidth=lwidth[i], dash=dashPattern,
+                      label=paste("lower ", round(100*actualPercent),"% limit", sep=""),
+                      parent=layer_group,
+                      index="end"
+         )
+         
+         l_layer_line(p3, quantiles, NumsPct[2 * nLevels - i + 1, ], 
+                      color=lineCols[i], 
+                      linewidth=lwidth[i], dash=dashPattern,
+                      label=paste("upper ", round(100*actualPercent),"% limit", sep=""),
+                      parent=layer_group,
+                      index="end"
+         )
+         
+     }
+     
+     
+     l_layer_texts(p3, x=c(-2,2), y=quantile(fit$resid, c(0.1,0.9)),
+                   text=c("Residuals appear to\n have a short left tail", 
+                          "Residuals appear to\n have a Gaussian right tail"),
+                   color="steelblue", angle=45, size=6)
+     
+     
+     
+     #
+     # Get waiting time and duration matching on the same eruption
+     
+     faithful2 <- data.frame(eruptions=faithful$eruptions[-n], 
+                             waiting=faithful$waiting[-1],
+                             groups=rep(1,(n-1))
+     )
+     
+     #
+     # Groups defined by Azzalini and Bowman paper in Applied Statistics, 1990
+     #
+     faithful2$groups[faithful2$eruptions >= 3 & faithful2$waiting >= 68] <- 2
+     faithful2$groups[faithful2$eruptions < 3 & faithful2$waiting >= 68] <- 3
+     faithful2$groups[faithful2$eruptions < 3 & faithful2$waiting < 68] <- 4
+     
+     p4 <- with(faithful2, 
+                l_plot(x=eruptions, 
+                       y=waiting,
+                       size=10,
+                       xlabel="Duration of eruption (minutes)",
+                       ylabel="Waiting time to this eruption (minutes)",
+                       title="Plot used by Azzalini and Bowman, 1990, to define groups",
+                       color=groups,
+                       showGuides=TRUE,
+                       linkingGroup="Old faithful",
+                       sync="push"
+                )
+     )
+ })


	demo(l_regression_influential)
	---- ~~~~~~~~~~~~~~~~~~~~~~~~

> local({
+     ## Fit simple linear regresion
+     fit <- lm(Fertility~Infant.Mortality, data=swiss)
+     
+     ## Data
+     p <- with(swiss, l_plot(Fertility~Infant.Mortality,
+                             title='swiss data (least-squares)',
+                             linkingGroup='swiss',
+                             itemLabel=rownames(swiss)))
+     
+     ## layer fit
+     xrng <- range(swiss$Infant.Mortality)
+     yhat <- predict(fit, data.frame(Infant.Mortality=xrng))
+     l_layer_line(p, x=xrng, y=yhat, linewidth=3, index="end")
+     
+     ## Fitted vs. Residuals
+     pr <- l_plot(x=fit$fitted, y=fit$resid,
+                  xlabel="Fitted values",
+                  ylabel="Residuals",
+                  title="Residuals vs. fitted values",
+                  linkingGroup='swiss',
+                  itemLabel=rownames(swiss))
+     
+     l_layer_line(pr, x=c(-25,100), y=c(0,0),
+                  linewidth=3, color="gray80",
+                  index="end")
+     
+     ## Influential Points
+     plev <- l_plot(x=hatvalues(fit), y=rstudent(fit),
+                    title="Leverage and outlier plot",
+                    ylabel="Externally studentized residuals",
+                    xlabel="hat values",
+                    linkingGroup="swiss",
+                    itemLabel=rownames(swiss))
+     
+     llev <- l_layer_line(plev, index='end',
+                          x=rep(4/plev['n'],2), y=c(-5,5),
+                          linewidth=3, color='gray80')
+     
+     
+     ## Layer Confidence Intervals
+     xpvals <- with(swiss, seq(from=min(Infant.Mortality),to=max(Infant.Mortality),
+                               length.out=60))
+     
+     conf95 <- predict(fit, data.frame(Infant.Mortality=xpvals),
+                       interval="confidence", level=0.95)
+     
+     conf99 <- predict(fit, data.frame(Infant.Mortality=xpvals),
+                       interval="confidence", level=0.99)
+     
+     pred95 <- predict(fit, data.frame(Infant.Mortality=xpvals),
+                       interval="prediction", level=0.95)
+     
+     pred99 <- predict(fit, data.frame(Infant.Mortality=xpvals),
+                       interval="prediction", level=0.99)
+     
+     
+     ## Interactively remove points from OLS
+     use_color <- p['color'][1]
+     
+     l.sel <- l_layer_line(p, x=xrng, y=yhat, color='red', linewidth=3,
+                           index="end")
+     
+     confg <- l_layer_group(p, label="Confidence intervals", index="end")
+     predg <- l_layer_group(p, label="Prediction intervals", index="end")
+     
+     
+     polyc95 <- l_layer_polygon(p,
+                                x=c(xpvals,rev(xpvals)),
+                                y=c(conf95[,2],rev(conf95[,3])),
+                                color="lightblue2",
+                                linecolor="",
+                                parent=confg,
+                                label="95% confidence",
+                                index="end")
+     
+     polyc99 <- l_layer_polygon(p,
+                                x=c(xpvals,rev(xpvals)),
+                                y=c(conf99[,2],rev(conf99[,3])),
+                                color="lightblue1",
+                                linecolor="",
+                                parent=confg,
+                                label="99% confidence",
+                                index="end")
+     
+     polyp95 <- l_layer_polygon(p,
+                                x=c(xpvals,rev(xpvals)),
+                                y=c(pred95[,2],rev(pred95[,3])),
+                                color="lightpink2",
+                                linecolor="",
+                                parent=predg,
+                                label="95% prediction",
+                                index="end")
+     
+     polyp99 <- l_layer_polygon(p,
+                                x=c(xpvals,rev(xpvals)),
+                                y=c(pred99[,2],rev(pred99[,3])),
+                                color="lightpink1",
+                                linecolor="",
+                                parent=predg,
+                                label="99% prediction",
+                                index="end")
+     
+     l_scaleto_world(p)
+     
+     
+     updateRegression <- function() {
+         ## which points to use for regression
+         sel <- p['color'] == use_color
+         sel <- sel & p['active']
+         ## which coordinates to use for regression
+         xnew <- p['xTemp']
+         if (length(xnew) == 0) {
+             xnew <- p['x']
+         }
+         
+         ynew <- p['yTemp']
+         if (length(ynew) == 0) {
+             ynew <- p['y']
+         }
+         
+         fit.temp <- lm(y~x, subset(data.frame(x=xnew, y=ynew), sel))
+         
+         xrng <- range(xnew)
+         
+         ## the fitted line
+         yhat <- predict(fit.temp, data.frame(x=xrng))
+         l_configure(l.sel, y=yhat, x=xrng)
+         
+         ## the intervals
+         ##
+         xpvals.temp <- seq(from=min(xrng),to=max(xrng),
+                            length.out=60)
+         
+         conf95.temp <- predict(fit.temp, data.frame(x=xpvals.temp),
+                                interval="confidence", level=0.95)
+         
+         conf99.temp <- predict(fit.temp, data.frame(x=xpvals.temp),
+                                interval="confidence", level=0.99)
+         
+         pred95.temp <- predict(fit.temp, data.frame(x=xpvals.temp),
+                                interval="prediction", level=0.95)
+         
+         pred99.temp <- predict(fit.temp, data.frame(x=xpvals.temp),
+                                interval="prediction", level=0.99)
+         
+         ## update the prediction intervals
+         ##
+         l_configure(polyp99,
+                     x=c(xpvals.temp,rev(xpvals.temp)),
+                     y=c(pred99.temp[,2],rev(pred99.temp[,3])))
+         
+         l_configure(polyp95,
+                     x=c(xpvals.temp,rev(xpvals.temp)),
+                     y=c(pred95.temp[,2],rev(pred95.temp[,3])))
+         
+         ## update the confidence intervals
+         ##
+         l_configure(polyc99,
+                     x=c(xpvals.temp,rev(xpvals.temp)),
+                     y=c(conf99.temp[,2],rev(conf99.temp[,3])))
+         
+         l_configure(polyc95,
+                     x=c(xpvals.temp,rev(xpvals.temp)),
+                     y=c(conf95.temp[,2],rev(conf95.temp[,3])))
+         
+         
+         #l_scaleto_world(p)
+         
+         ## resids versus fitted plot
+         fitted <- predict(fit.temp, data.frame(x=xnew))
+         l_configure(pr, x=fitted, y=ynew - fitted)
+         
+         ## leverage plot
+         l_configure(plev, x=hatvalues(fit.temp), y=rstudent(fit.temp),
+                     linkingKey=which(sel)-1, sync="pull")
+         l_scaleto_world(plev)
+         l_configure(llev, x=rep(4/sum(sel),2))
+         tcl('update', 'idletasks')
+     }
+     
+     bnd <- l_bind_state(p, c("color","active","xTemp","yTemp"),
+                         function()updateRegression())
+     
+     ## Map
+     library(maps)
+     m <- map("world", 'Switzerland', fill=TRUE, plot=FALSE)
+     ## Coordinates
+     swissCoords <- structure(list(
+         latitude = c(47.1783274, 47.365837, 47.254872, 
+                      47.2782749, 47.0632023, 47.416647, 46.5892626, 46.761285, 46.6757485, 
+                      46.7866673, 46.5280339, 46.3190253, 46.4953291, 46.8806009, 46.6140944, 
+                      46.6410996, 46.8092091, 46.5196535, 46.4312213, 46.5, 46.5088127, 
+                      46.6698891, 46.3832683, 46.7293301, 46.566667, 46.8220266, 46.4666667, 
+                      46.4612971, 46.4628333, 46.7784736, 46.2244777, 46.0163423, 46.0801475, 
+                      46.1049798, 46.2521873, 46.214941, 46.2941311, 46.2331221, 46.9542921, 
+                      47.1034892, 47.0577195, 46.9899874, 47.083333, 46.9, 46.2043907, 
+                      46.2083126, 46.2455233),
+         longitude = c(7.0729547, 7.3451555, 
+                       7.0028421, 7.3716656, 7.0912628, 7.0765657, 6.9555376, 7.0901001, 
+                       7.095521, 7.1621113, 6.9175828, 6.970566, 6.3918325, 7.0427075, 
+                       6.507171, 6.6344508, 6.6457678, 6.6322734, 6.9106799, 6.75, 6.4961301, 
+                       6.7975224, 6.2347852, 6.5323588, 6.833333, 6.9405663, 7.0833333, 
+                       6.3397549, 6.8419192, 6.641183, 7.303512, 7.2706464, 7.4698932, 
+                       7.0755334, 6.9469598, 7.0047948, 7.5335362, 7.360626, 6.8478409, 
+                       6.8327838, 6.7487354, 6.9292732, 6.966667, 6.6, 6.1431577, 6.1458643, 
+                       6.2090779)),
+         .Names = c("latitude", "longitude"),
+         row.names = c("Courtelary Switzerland", 
+                       "Delemont Switzerland", "Franches-Mnt Switzerland", "Moutier Switzerland", 
+                       "Neuveville Switzerland", "Porrentruy Switzerland", "Broye Switzerland", 
+                       "Glane Switzerland", "Gruyere Switzerland", "Sarine Switzerland", 
+                       "Veveyse Switzerland", "Aigle Switzerland", "Aubonne Switzerland", 
+                       "Avenches Switzerland", "Cossonay Switzerland", "Echallens Switzerland", 
+                       "Grandson Switzerland", "Lausanne Switzerland", "La Vallee Switzerland", 
+                       "Lavaux Switzerland", "Morges Switzerland", "Moudon Switzerland", 
+                       "Nyone Switzerland", "Orbe Switzerland", "Oron Switzerland", 
+                       "Payerne Switzerland", "Paysd'enhaut Switzerland", "Rolle Switzerland", 
+                       "Vevey Switzerland", "Yverdon Switzerland", "Conthey Switzerland", 
+                       "Entremont Switzerland", "Herens Switzerland", "Martigwy Switzerland", 
+                       "Monthey Switzerland", "St Maurice Switzerland", "Sierre Switzerland", 
+                       "Sion Switzerland", "Boudry Switzerland", "La Chauxdfnd Switzerland", 
+                       "Le Locle Switzerland", "Neuchatel Switzerland", "Val de Ruz Switzerland", 
+                       "ValdeTravers Switzerland", "V. De Geneve Switzerland", "Rive Droite Switzerland", 
+                       "Rive Gauche Switzerland"),
+         class = "data.frame")
+     
+ 
+     p_map <- with(swissCoords, l_plot(longitude,latitude,
+                                       itemLabel=rownames(swissCoords),
+                                       showItemLabels=TRUE,
+                                       linkingGroup='swiss'))
+     
+     l <- l_layer(p_map, m, index=1)
+     l_layer_lower(p_map, l)
+     l_scaleto_world(p_map)
+     
+ })


	demo(l_scagnostics)
	---- ~~~~~~~~~~~~~

> require(scagnostics) || stop("require scagnostics package")
Loading required package: scagnostics
Loading required package: rJava
[1] TRUE

> local({
+ 
+     ## Scatterplot Matrix of scagnostic measures
+     data <- oliveAcids
+     scags <- scagnostics(data)
+     scdata <- as.data.frame(t(unclass(scags)))
+     npairs <- dim(scdata)[1]
+     variablePairs <- rownames(scdata)
+     
+     ps <- l_pairs(scdata, itemLabel=variablePairs)
+ 
+     ## Scatterplot two variates
+     p <- with(olive, l_plot(oleic~stearic, color=Area))
+ 
+     ## select the above plot in the scatterplot matrix
+     l_configure(ps[[1]], selected = TRUE, size = 12,
+                 which = variablePairs=="stearic * oleic")
+     
+     scag2var <- function() {
+         ## resize the point whose respective scatterplot is shown
+         sel <- which(ps[[1]]['selected'])
+         
+         if (length(sel) > 0) {
+             ## select the fist plot
+             sel <- sel[1]
+             varPair <- unlist(strsplit(variablePairs[sel], ' * ', fixed = TRUE))
+             xvar <- varPair[1]
+             yvar <- varPair[2]
+             
+             l_configure(p, x=data[[xvar]], y=data[[yvar]],
+                         xlabel=xvar, ylabel=yvar)
+ 
+             l_scaleto_world(p)
+ 
+             ## otherwise you get nested configure evaluation for some plots
+             l_after_idle(
+                 function () {
+                     ## enlarge point representing active scatterplot
+                     size <- rep(4, npairs)
+                     size[sel] <- 12
+                     l_configure(ps[[1]], size=size)
+                 })
+         }
+     }
+ 
+     ## only need to add state binding for first scatterplot
+     ## as all scatterplots are linked
+     bnd <- l_bind_state(ps[[1]], 'selected', function() {scag2var()} )
+     
+ })


	demo(l_selectToActive)
	---- ~~~~~~~~~~~~~~~~

> local({
+     # Bivariate normal parameterized by principal axis sds and rotation of major axis
+     rbvn <- function(n=1, mean=c(0,0), sd = c(1,1), rotation=0 ) {
+         data <- matrix(rnorm(n*2),ncol=2)
+         rotMat <- matrix(c(cos(rotation), -sin(rotation), 
+                            sin(rotation),  cos(rotation)), 
+                          ncol=2,byrow=TRUE)
+         data[,1] <- data[,1]*sd[1]
+         data[,2] <- data[,2]*sd[2]
+         data <- data %*% t(rotMat)
+         data[,1] <- data[,1]  +  mean[1]
+         data[,2] <- data[,2]  +  mean[2]
+         data
+         
+     }
+     
+     
+     
+     #
+     # Create dependent data for illustration
+     n <- 30
+     m <- 20
+     sd <- c(3,1)
+     rotation <- -pi/4
+     means <- rbvn(m,sd=c(4,1), rotation = pi/4)
+     
+     data1 <- matrix(0, nrow=n*m, ncol=2)
+     
+     for (i in 1:m){
+         ##i <- 0
+         ##i <- i+1
+         from <- (i-1)*n + 1
+         to <- i*n
+         data1[from:to,] <- rbvn(n,mean=means[i,], sd= sd, rotation=rotation)
+     }
+     data2 <- matrix(rep(means,each=n),ncol=2,byrow=FALSE) + rbvn(n*m, sd=c(1.1,1.1))
+     
+     data <- as.data.frame(cbind(data1,data2))
+     names(data) <-c("x","y","u","v")
+     head(data)
+     
+     ##
+     ## Have a look
+     pairs(data[,c("x","y")])      # no relation
+     pairs(data[,c("x","u","v")])  # increasing relations
+     pairs(data[,c("y","u","v")])  # increasing relations
+     pairs(data)
+     
+     
+     #
+     # Now with brushing
+     #
+     pa <- with(data, l_plot(x=x, y=y, main="active here"))
+     ps <- with(data, l_plot(x=u, y=v, main = "select here"))
+     
+     active2selected <- function() {
+         ps['selected'] <- pa['active']
+     } 
+     
+     selected2active <- function() {
+         pa['active'] <- ps['selected']
+     } 
+     
+     l_bind_state(pa, "active", function()active2selected())
+     l_bind_state(ps, "selected", function()selected2active())
+     
+     ## Brush  on "selected" and watch "active"
+     ## long skinny brushes condition on either u (vertical skinny) or v (horizontal skinny)
+     ##  ... neither producing that strong a relation in x and y (esp. in the middle)
+     ## small square brush conditions on u and v together.
+     ##  ... should see (conditionally) negative relation between x and y 
+     ##      pretty much everywhere 
+     ##
+     ##  Now for something more challenging.
+     ##
+     
+     Allx <- l_cget(pa,"x")
+     Ally <- l_cget(pa,"y")
+     xrange <- range(Allx)
+     coef <- lm(Ally ~ Allx)$coef
+     yVal <- coef[1] + xrange*coef[2]
+     fitAll <- l_layer_line(pa, x=xrange, y=yVal,
+                            color="black", linewidth=3, label="fit on all data")
+     fitActive <- l_layer_line(pa, x=xrange, y=yVal, color="magenta",
+                               linewidth=5, dash=c(10,5), label="fit on active data")
+     
+     ## redefine selected2active with fit
+     selected2active <- function() {
+         pa['active'] <- ps['selected']
+         x <- l_cget(pa,"x")[l_cget(pa,"active")]
+         y <- l_cget(pa,"y")[l_cget(pa,"active")]
+         if (length(x) > 1) {
+             xrange <- range(x)
+             if (diff(xrange)>0){
+                 coef <- lm(y ~ x)$coef
+                 yVal <- coef[1] + xrange*coef[2]
+                 l_configure(fitActive, x=xrange, y=yVal)
+             }
+         }
+     }
+ })
warning: please do not use state abbrevations, i.e. use "title" instead of "main".
warning: please do not use state abbrevations, i.e. use "title" instead of "main".


	demo(l_timeseries)
	---- ~~~~~~~~~~~~

> local({
+     pco2 <- l_plot(co2, title="Atmospheric carbon dioxide over Mauna Loa", 
+                    ylabel="CO2 (ppm)", linkingGroup="co2", showScales=TRUE, showGuides=TRUE)
+     
+     xy.raw <- xy.coords(co2)
+     l_layer_line(pco2, x= xy.raw$x, y= xy.raw$y, index="end", label="connect the dots")
+     
+     co2.stl <- stl(co2,"per")$time.series
+     
+     
+     readline("Add a fitted trend to the data. Press the <enter> key to continue: ")
+     
+     xy.trend <- xy.coords(co2.stl[,"trend"])
+     l_layer_line(pco2, x= xy.trend$x, y= xy.trend$y, color="brown", linewidth=3,index="end", label="trend")
+     
+     readline("Add a fitted seasonal component to the trend. Press the <enter> key to continue: ")
+     
+     xy.seasonal <- xy.coords(co2.stl[,"seasonal"])
+     l_layer_line(pco2, x= xy.seasonal$x, y= xy.seasonal$y + xy.trend$y, color="green", linewidth=3,index="end", label="trend + seasonal")
+     
+     
+     readline("Display a seasonal trend analysis (stl) in a single window. Press the <enter> key to continue: ")
+     
+     ## Tk geometry managers like grid and pack may be used
+     ## to place the widgets
+     
+     ## With pack stack three scatterplots that share the same x on top
+     ## and bind the zoomX and panX
+     tt <- tktoplevel()
+     tktitle(tt) <- "Seasonal Trend Analysis"
+     
+     p1 <- l_plot(parent=tt, x= co2, color="steelblue", size=1,
+                  ylabel="CO2 data (ppm)", xlabel="Time",
+                  title="Atmospheric carbon dioxide over Mauna Loa",
+                  linkingGroup="co2", showScales=TRUE, showGuides=TRUE, showLabels=TRUE)
+     l_layer_line(p1, x= xy.raw$x, y= xy.raw$y,  color="steelblue",
+                  linewidth=1, index="end", label="connect the dots")
+     
+     
+     p2 <- l_plot(parent=tt, x= xy.trend$x, y= xy.trend$y, color="steelblue", size=1,
+                  ylabel="CO2 trend", xlabel="Time",
+                  linkingGroup="co2", showScales=TRUE, showGuides=TRUE, showLabels=TRUE)
+     l_layer_line(p2, x= xy.trend$x, y= xy.trend$y, color="brown",
+                  linewidth=1,index="end", label="trend")
+     
+     
+     p3 <- l_plot(parent=tt, x= xy.seasonal$x, y= xy.seasonal$y,color="steelblue", size=1,
+                  ylabel="CO2 seasonality", xlabel="Time",
+                  linkingGroup="co2", showScales=TRUE, showGuides=TRUE, showLabels=TRUE)
+     l_layer_line(p3, x= xy.seasonal$x, y= xy.seasonal$y, color="green", 
+                  linewidth=1,index="end", label="seasonal")
+     
+     xy.remainder <- xy.coords(co2.stl[,"remainder"])
+     
+     p4 <- l_plot(parent=tt, x= xy.remainder$x, y= xy.remainder$y,color="steelblue", size=1,
+                  ylabel="CO2 remainder", xlabel="Time",
+                  linkingGroup="co2", showScales=TRUE, showGuides=TRUE, showLabels=TRUE)
+     l_layer_line(p4, x= xy.remainder$x, y= xy.remainder$y, color="grey",
+                  linewidth=1,index="end", label="remainder")
+     
+     
+     
+     ## make the canvas resize to fairly small
+     
+     for (p in c(p1,p2,p3,p4)) {
+         tkconfigure(paste(p,".canvas", sep=''), width=500, height=150)
+     }
+     
+     tkpack(p1, p2, p3, p4, fill="both", expand=TRUE)
+     
+     
+     ## Bind so that they show the same x range
+     l_bind_state(p1, c("panX", "zoomX"), function(W)updateZoomPan(W))
+     l_bind_state(p2, c("panX", "zoomX"), function(W)updateZoomPan(W))
+     l_bind_state(p3, c("panX", "zoomX"), function(W)updateZoomPan(W))
+     l_bind_state(p4, c("panX", "zoomX"), function(W)updateZoomPan(W))
+     
+     busy <- FALSE
+     updateZoomPan <- function(widget) {
+         if (!busy) {
+             busy <- TRUE
+             zoomX <- l_cget(widget, "zoomX")
+             panX <- l_cget(widget, "panX")
+             
+             for (w in c(p1, p2, p3, p4)) {
+                 l_configure(w, panX=panX, zoomX=zoomX)
+             }
+             
+             busy <- FALSE
+         }
+     }
+     
+     
+     
+     
+     readline("Add the remainder's five number summary to all plots. Press the <enter> key to continue: ")
+     
+     five <- fivenum(xy.remainder$y)
+     ymin <- five[1]
+     q1   <- five[2]
+     med  <- five[3]
+     q3   <- five[4]
+     ymax <- five[5]
+     
+     readline("Add lag (1-12) plots. Press the <enter> key to continue: ")
+     
+     tt2 <- tktoplevel()
+     tktitle(tt2) <- "Lag (1-12) plots"
+     
+     nlags <- 12
+     n <- length(xy.raw$y)
+     
+     ## create plots
+     plots <- vector("list",nlags)
+     for (i in 1:nlags){
+         plots[[i]] <- l_plot(parent=tt2, 
+                              x=xy.raw$y[1:(n-i)],
+                              y=xy.raw$y[-(1:i)],
+                              showLabels=TRUE,
+                              showGuides=TRUE,
+                              linkingGroup="co2",
+                              ylabel="CO2",
+                              xlabel=paste("CO2(-",i,")",sep=""),
+                              title="")
+         
+     }
+     
+     ## resize the min canvas size
+     sapply(plots, function(p) {
+         tkconfigure(paste(p,'.canvas',sep=''), width=200, height=200)
+     })
+     
+     ## grid layout
+     nrow <- floor(sqrt(nlags))
+     ncol <- ceiling(sqrt(nlags))
+     for (i in 1:nrow){
+         for (j in 1:ncol){
+             index <- (i-1)*ncol +  j
+             tkgrid(plots[[index]], 
+                    row=i, column=j, 
+                    sticky="nesw"
+             )
+         }
+     }    
+     
+     ## Column and Row weight such that the cells expand
+     for (i in 1:ncol) {
+         tkgrid.columnconfigure(tt2, i, weight = 1)
+     }
+     for (i in 1:nrow) {
+         tkgrid.rowconfigure(tt2, i, weight = 1)
+     }
+     
+ })
Add a fitted trend to the data. Press the <enter> key to continue: 
Add a fitted seasonal component to the trend. Press the <enter> key to continue: 
Display a seasonal trend analysis (stl) in a single window. Press the <enter> key to continue: 
Add the remainder's five number summary to all plots. Press the <enter> key to continue: 
Add lag (1-12) plots. Press the <enter> key to continue: 


	demo(l_us_and_them)
	---- ~~~~~~~~~~~~~

> ## Gapminder Data
> library(dplyr)

Attaching package: 'dplyr'

The following object is masked from 'package:MASS':

    select

The following object is masked from 'package:graph':

    union

The following objects are masked from 'package:BiocGenerics':

    combine, intersect, setdiff, union

The following objects are masked from 'package:stats':

    filter, lag

The following objects are masked from 'package:base':

    intersect, setdiff, setequal, union


> local({
+     data(UsAndThem)
+     head(UsAndThem)
+     
+     colorkey = list('America'='#E5FF2F',
+                     'Europe & Central Asia'='#FF982F',
+                     'Middle East & North Africa'='#68FF5E',
+                     'Sub-Saharan Africa'='#3F4FFF',
+                     'South Asia'='#36BEE3',
+                     'East Asia & Pacific'='#FF2F2F')
+     
+     scale01 <- function(x) {(x-min(x))/diff(range(x))}
+     
+     sel <- UsAndThem$Year == 2009
+     sum(sel)
+     
+     LifeExpectancy <- UsAndThem$LifeExpectancy[sel]
+     Fertility <- UsAndThem$Fertility[sel]
+     Income <- UsAndThem$Income[sel]
+     
+     region_cols <- unlist(colorkey)[match(UsAndThem$Geographic.Region[sel], names(colorkey))]
+     pop_size <- scale01(UsAndThem$Population[sel])*200
+     country <- as.character(UsAndThem$Country[sel])
+     
+     p1 <- l_plot(y=LifeExpectancy, x=Fertility,
+                  color=region_cols, size=pop_size,
+                  itemLabel=country,
+                  linkingGroup="world")
+     
+     p2 <- l_plot(y=LifeExpectancy, x=Income,
+                  itemLabel=country,
+                  linkingGroup="world")
+     
+     h <- l_hist(x=Income/1000, linkingGroup="world")
+     
+     
+     ## Create Time series
+     head(UsAndThem)
+     
+     # split data by country and arrange them by year
+     sdat <- split(UsAndThem, UsAndThem$Country)
+     sdat2 <- lapply(sdat, function(dat) {
+         arrange(dat, Year)
+     })
+     
+     # How many observations per year per country
+     vapply(sdat2, nrow, numeric(1))
+     
+     # Extract data with 52 observations
+     sdat3 <- Filter(function(x)nrow(x)==52, sdat2)
+     
+     # Check if the years are all the same
+     tmp.year <- sdat3[[1]]$Year
+     any(vapply(sdat3, function(x)any(x$Year!=tmp.year), logical(1)))
+     
+     # Now create a data frame with years in columns and countries in row
+     # for LifeExpectancy
+     dat4 <- vapply(sdat3, function(x)x$Income, numeric(52))
+     rownames(dat4) <- tmp.year
+     
+     dat4[,c("Kuwait", "United States")]
+     
+     dat5 <- as.data.frame(t(dat4))
+     
+     head(dat5)
+     is.data.frame(dat5)
+     
+     
+     sa <- l_serialaxes(data=dat5, linkingGroup="world",
+                        scaling="data", axesLayout="parallel",
+                        title='Income', itemLabel=rownames(dat5))
+     
+     sa['linewidth'] <- 2
+     
+     rownames(dat5)[sa['selected']]
+     
+     ## Can I keep the optimized linkingKeys?
+     ## any(country != rownames(dat5))
+     ## no> use new linkingKeys
+     l_configure(p1, linkingKey=country, sync="push")
+     l_configure(p2, linkingKey=country, sync="push")
+     l_configure(h, linkingKey=country, sync="push")
+     l_configure(sa, linkingKey=rownames(dat5), sync="pull")
+     
+ })


	demo(l_us_and_them_choropleth)
	---- ~~~~~~~~~~~~~~~~~~~~~~~~

> require(dplyr) || stop('package dplyr required')
[1] TRUE

> require(rworldmap) || stop('package rworldmap required')
Loading required package: rworldmap
### Welcome to rworldmap ###
For a short introduction type : 	 vignette('rworldmap')
[1] TRUE

> require(RColorBrewer) || stop('package RColorBrewer required')
[1] TRUE

> local({
+     #' Link Points With Map and Vice Versa
+ 
+     
+     scale01 <- function(x) {(x-min(x))/(max(x)-min(x))}
+     
+     ## Color Gradient to Map Life Expectancy on Map
+     colfn <- colorRamp(brewer.pal(9, name="YlOrBr"), alpha=FALSE)
+     
+     
+     data(UsAndThem)
+     colorkey = list('America'='#E5FF2F',
+                     'Europe & Central Asia'='#FF982F',
+                     'Middle East & North Africa'='#68FF5E',
+                     'Sub-Saharan Africa'='#3F4FFF',
+                     'South Asia'='#36BEE3',
+                     'East Asia & Pacific'='#FF2F2F')
+     
+     
+     dat <- UsAndThem %>%
+         filter(Year == 2002) %>%
+         mutate(Region.Color = unlist(colorkey[match(Geographic.Region,names(colorkey))]))
+     
+     head(dat)
+     
+     LifeExpectancyColor <- sapply(scale01(dat$LifeExpectancy), function(val) {
+         col <- colfn(val)
+         rgb(col[1], col[2], col[3], maxColorValue=255)
+     } )
+     
+     
+     ## plot of life expectancy versus fertility
+     p <- with(dat, l_plot(LifeExpectancy ~ Fertility, color=Region.Color,
+                           size=scale01(Population)*120+2,
+                           itemLabel=as.character(dat$Country),
+                           showItemLabels=TRUE,
+                           background='gray20',
+                           foreground='gray95',
+                           guidesBackground = 'gray20',
+                           guidelines = 'gray30',
+                           showGuides=TRUE,
+                           glyph='ccircle',
+                           showScales=TRUE,
+                           linkingKey=as.character(Country)))
+     
+     ## Choropleth Map
+     world <- getMap(resolution = "coarse")
+     p_map <- l_plot() # background='#71ABDB'
+     
+     l_map <- l_layer(p_map, world, asSingleLayer=TRUE, index="end", label="world map")
+     l_scaleto_world(p_map)
+     
+     map_countries <- tolower(attr(l_map, "NAME"))
+     data_countries <- tolower(as.character(dat$Country))
+     
+     fromto <- list(c("antigua and barb.","antigua and barbuda"),
+                    c("bosnia and herz.", "bosnia and herzegovina"),
+                    c("congo (kinshasa)", "congo, dem. rep."),
+                    c("congo (brazzaville)", "congo, rep."),
+                    c("ivory coast", "cote d'ivoire"),
+                    c("eq. guinea", "equatorial guinea"),
+                    c("fr. polynesia", "french polynesia"),
+                    c("guinea bissau", "guinea-bissau"),
+                    c("hong kong", "hong kong, china"),
+                    c("n. korea","korea, rep."),
+                    c("s. korea", "korea, dem. rep."),
+                    c("macau", "macao, china"),
+                    c("macedonia", "macedonia, fyr"),
+                    c("micronesia", "micronesia, fed. sts."),
+                    c("st. vin. and gren.", "saint vincent and the grenadines"),
+                    c("slovakia", "slovak republic"),
+                    c("solomon is.", "solomon islands"),
+                    c("s. sudan", "south sudan"),
+                    c("east timor","timor-leste"),
+                    c("gaza", "west bank and gaza"),
+                    c("west bank", "west bank and gaza"),
+                    c("yemen", "yemen, rep."))
+     
+     for(l in fromto) {
+         map_countries[map_countries == l[1]] <- l[2]
+     }
+     
+     map_Country2Wmap <- lapply(data_countries, function(x) {
+         which(x == map_countries)
+     })
+     names(map_Country2Wmap) <- data_countries
+     
+     
+     # grep("slovak", data_countries, value = TRUE)
+     # grep("yemen", map_countries, value = TRUE)
+     # names(Filter(function(x)length(x)==0, map_Country2Wmap))
+     ## Not Found             
+     # "guadeloupe"
+     # "martinique"
+     # "netherlands antilles"
+     # "reunion"
+     
+     
+     #    printTags <- function(W) {
+     #        print(l_currenttags(W))
+     #    }
+     #    l_bind_item(p_map, 'all', '<ButtonPress>', printTags)
+     #    l_map['tag'] <- attr(l_map, "NAME")
+     
+     map_Wmap2Country <- match(map_countries, data_countries)
+     
+     
+     LifeExpectancyMapColor <- rep("grey80", l_map['n'])
+     invisible(Map(function(i, col){
+         if(length(i) > 0) {
+             LifeExpectancyMapColor[i] <<- col
+         }
+     }, map_Country2Wmap, LifeExpectancyColor))
+     
+     l_map['color'] <- LifeExpectancyMapColor
+     
+     updateMap_sp <- function() {
+         i <- unlist(map_Country2Wmap[p['selected']])
+         cols <- LifeExpectancyMapColor
+         if(!is.null(i)) {
+             cols[Filter(function(x)!is.na(x),i)] <- 'magenta'
+         }
+         l_map['color'] <- cols
+     }
+     
+     b <- l_bind_state(p, 'selected', function(){updateMap_sp()})
+     
+     
+     updatePlot_sp <- function(add) {
+         i <- l_currentindex(p_map)
+         if(i !=-1 && !is.na(map_Wmap2Country[i])) {
+             if (add) {
+                 l_configure(p, selected=TRUE, which=map_Wmap2Country[i])
+             } else {
+                 sel <- rep(FALSE, p['n'])
+                 sel[map_Wmap2Country[i]] <- TRUE
+                 p['selected'] <- sel
+             }
+         }
+     }
+     
+     b2 <- l_bind_item(p_map, paste0('layer&&',l_map), '<ButtonPress-1>',
+                       function(){updatePlot_sp(FALSE)})
+     b3 <- l_bind_item(p_map, paste0('layer&&',l_map), '<Shift-ButtonPress-1>',
+                       function(){updatePlot_sp(TRUE)})
+ })


	demo(l_us_and_them_slider)
	---- ~~~~~~~~~~~~~~~~~~~~

> local({
+     
+     ## Example from Hans Rosling Talk
+     ## https://www.ted.com/talks/hans_rosling_shows_the_best_stats_you_ve_ever_seen
+     
+     data("UsAndThem")
+     
+     scale01 <- function(x) {(x-min(x))/diff(range(x))}
+     
+     tt <- tktoplevel()
+     tktitle(tt) <- "Us and Them"
+     
+     colorkey = list('America'='#E5FF2F',
+                     'Europe & Central Asia'='#FF982F',
+                     'Middle East & North Africa'='#68FF5E',
+                     'Sub-Saharan Africa'='#3F4FFF',
+                     'South Asia'='#36BEE3',
+                     'East Asia & Pacific'='#FF2F2F')
+     
+     
+     sel <- UsAndThem$Year==1962
+     p <- with(UsAndThem,
+               l_plot(x=Fertility[sel], y=LifeExpectancy[sel],
+                      parent=tt,
+                      color=unlist(colorkey)[match(Geographic.Region[sel],
+                                                   names(colorkey))],
+                      size=scale01(Population[sel])*200,
+                      title="Us and Them",
+                      xlabel="Fertility", ylabel="Life Expectancy",
+                      itemLabel=as.character(Country[sel]),
+                      glyph='ccircle',
+                      linkingKey=as.character(Country[sel])))
+     
+     updateYear <- function() {
+         year <- as.numeric(tclvalue(SliderValue))
+         sel <- UsAndThem$Year==year
+         if (sum(sel) > 0) {
+             with(UsAndThem,
+                  l_configure(p,
+                              x=Fertility[sel], y=LifeExpectancy[sel],
+                              color=unlist(colorkey)[match(Geographic.Region[sel],
+                                                           names(colorkey))],
+                              size=scale01(Population[sel])*200,
+                              itemLabel=as.character(Country[sel]),
+                              glyph='ccircle',
+                              linkingKey=as.character(Country[sel]),
+                              sync='pull'))
+             l_configure(tl, text=year)
+             tcl("update", "idletasks")
+         }
+     }
+     
+     
+     tl <- l_layer_text(p, x=2, y=30, text="1962", size=60, index="end", color="gray70")
+     slider <- tkscale(tt, from=min(UsAndThem$Year),to=max(UsAndThem$Year),resolution=1, showvalue=TRUE, orient="horizontal" )
+     
+     SliderValue <- tclVar("1962")
+     tkconfigure(slider, variable=SliderValue, command=function(...)updateYear())
+ 
+     tkpack(slider, fill="x", side='bottom')
+     tkpack(p, side='bottom', fill="both", expand=1)
+     
+ })
<Tcl>  


	demo(l_widgets)
	---- ~~~~~~~~~

> local({
+     
+     tt <- tktoplevel()
+     p1 <- with(mtcars,
+                l_plot(parent=tt, x=mpg, y=hp, color=gear, title="mtcars",
+                              useLoonInspector=FALSE)
+                )
+     
+     tkpack(p1, side="left", fill="both", expand=TRUE)
+     
+     
+     ## Add a custom inspector (no layers)
+     f <- tkframe(tt)
+     lf <- tkwidget(f,"labelframe", text="Worldview")
+     wv <- l_worldview(parent=lf, activewidget=p1)
+     tkconfigure(paste(wv,".canvas", sep=""), width=50, height=160) 
+     ai <- l_plot_inspector_analysis(parent=f, activewidget=p1)
+ 
+     tkpack(f, side="right", anchor="ne")
+     tkpack(lf, side="top", fill="x")
+     tkpack(wv, side="top", fill="x")
+     tkpack(ai, side="top", fill="x")
+     tktitle(tt) <- "Custom Loon Plot"
+     
+ })
> 
> proc.time()
   user  system elapsed 
133.420   0.500 158.609 
